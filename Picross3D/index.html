<html>
<head>
    <link rel="stylesheet" href="mystyle.css">
    <meta name="viewport" content="width=device-width, user-scalable=no" />
</head>

<body onresize="WindowResize()" oncontextmenu="return false;"
        onmousedown="SetupRotation(event)" ontouchstart="SetupRotation(event)"
        onmouseup="StopRotation()" onmouseleave="StopRotation()" ontouchend="StopRotation()"
        onmousemove="RotateCube(event)" ontouchmove="RotateCube(event)">
    <div class="board" id="board">
        <div class="container" id="container">
        
        </div>
    </div>
    <div id="buttons" onmousedown="StopDrag(event)" >
        <input type="checkbox" name="interactions" id="Paint" onclick="LimitOne(this)" ontouchstart="LimitOne(this)" />
        <label for="Paint">Paint</label>
        <input type="checkbox" name="interactions" id="Destroy" onclick="LimitOne(this)" ontouchstart="LimitOne(this)" />
        <label for="Destroy">Destroy</label>
    </div>

<script>
    // Size = %vmin dimensions of each box, xSize = # of boxes left-right, ySize = # of boxes top-down, zSize = # of boxes front-back
    const size = 7;
    const xSize = 6;
    const ySize = 5;
    const zSize = 4;

    // Last used position of interaction point and if we should think about rotating
    var mouseX;
    var mouseY;
    var mouseDown = false;

    // Position the cube to the center of the screen
    WindowResize();

    // Set the transformation origin the center of the cube and 0 rotation
    var container = document.getElementById("container");
    container.style.transformOrigin = (size*xSize)/2.0 + "vmin " + (size*ySize)/2.0 +"vmin " + (size*zSize)/2.0 +"vmin";
    container.style.transform = `rotateX(0rad) rotateY(0rad) rotateZ(0rad)`;

   
    // Create the cubes
    for (i = 0; i < xSize; i++) {
        for (j = 0; j <ySize; j++) {
            for (k = 0; k < zSize; k++) {
                // Create and position the box
                var box = document.createElement("div");
                box.className = "box ";
                box.style.width = `${size}vmin`;
                box.style.left = `${size*(i)}vmin`
                box.style.top = `${size*(j)}vmin`;
                box.style.transform = "translateZ(" + size*(k) + "vmin)";
                box.id = i + " " + j + " " + k;
                container.appendChild(box);

                // Hide boxes that can't be see to save performance
                if ((i != 0 && i != xSize-1) && (j != 0 && j != ySize-1) && (k != 0 && k != zSize-1)) {
                    box.style.visibility = "hidden";
                }

                // Create the top face
                var topFace = document.createElement("div");
                topFace.style.width = `${size-0.1}vmin`;
                topFace.style.transform = "rotateX(90deg) translateZ(" +0.5*size + "vmin)";
                topFace.style.backgroundColor = "pink";
                topFace.className = "face";
                topFace.onclick = Interaction;
                topFace.addEventListener("touchstart", Interaction)
                topFace.addEventListener("mousedown", (e) => {StopDrag(e, true)});
                box.appendChild(topFace);

                // Create the bottom face
                var bottom = document.createElement("div");
                bottom.style.width = `${size-0.1}vmin`;
                bottom.style.transform = "rotateX(-90deg) translateZ(" +0.5*size + "vmin)";
                bottom.style.backgroundColor = "purple";
                bottom.className = "face";
                bottom.onclick = Interaction;
                bottom.addEventListener("touchstart", Interaction)
                bottom.addEventListener("mousedown", (e) => {StopDrag(e, true)});
                box.appendChild(bottom);

                // Create the back face
                var back = document.createElement("div");
                back.style.width = `${size-0.1}vmin`;
                back.style.transform = "rotateY(180deg) translateZ(" +0.5*size + "vmin)";
                back.style.backgroundColor = "yellow";
                back.className = "face";
                back.onclick = Interaction;
                back.addEventListener("touchstart", Interaction)
                back.addEventListener("mousedown", (e) => {StopDrag(e, true)});
                box.appendChild(back);

                // Create the front face
                var front = document.createElement("div");
                front.style.width = `${size-0.1}vmin`;
                front.style.transform = "translateZ(" +0.5*size + "vmin)";
                front.style.backgroundColor = "red";
                front.className = "face";
                front.onclick = Interaction;
                front.addEventListener("touchstart", Interaction)
                front.addEventListener("mousedown", (e) => {StopDrag(e, true)});
                box.appendChild(front);

                // Create the left face
                var left = document.createElement("div");
                left.style.width = `${size-0.1}vmin`;
                left.style.transform = "rotateY(-90deg) translateZ(" +0.5*size + "vmin)";
                left.style.backgroundColor = "green";
                left.className = "face";
                left.onclick = Interaction;
                left.addEventListener("touchstart", Interaction)
                left.addEventListener("mousedown", (e) => {StopDrag(e, true)});
                box.appendChild(left);

                // Create the right face
                var right = document.createElement("div");
                right.style.width = `${size-0.1}vmin`;
                right.style.transform = "rotateY(90deg) translateZ(" +0.5*size + "vmin)";
                right.style.backgroundColor = "blue";
                right.className = "face";
                right.onclick = Interaction;
                right.addEventListener("touchstart", Interaction)
                right.addEventListener("mousedown", (e) => {StopDrag(e, true)});
                box.appendChild(right);
            }
            
        }

    }

    // Reposition the cube when the window gets resized
    function WindowResize() {
        let w = document.documentElement.clientWidth;
        let h = document.documentElement.clientHeight;
        var board = document.getElementById("board");

        // Convert the larger to the smaller % to match the vmin of size
        if (w > h) {
            board.style.left = ((((w*100/h)/size) - xSize) / 2) * size + "vh";
            board.style.top = (((100.0/size) - ySize) / 2) * size + "vh";
        } else {
            board.style.left = (((100.0/size) - xSize) / 2) * size + "vw";
            board.style.top = ((((h*100/w)/size) - ySize) / 2) * size + "vw";
        }
    }

    // Stop Rotation from being setup when mouse goes down on a click event object
    function StopDrag(e, conditionally = false) {
        // If we want to allow drag while we don't have a cube interaction
        if ((conditionally && GetCubeInteraction() == null) || (e.buttons & (1 << 1) && !(e.buttons & (1 << 0)))) {
            return true;
        }
        e.stopPropagation();
    }

    // Limit a group of checkboxes to only have one box clicked at a time
    function LimitOne(checkbox) {
        var checkboxes = document.getElementsByName(checkbox.name);
        checkboxes.forEach((item) => {
            if (item != checkbox) {
                item.checked = false;
            }
        });
    }

    function GetCubeInteraction() {
        var checkboxes = document.getElementsByName("interactions");
        var interaction = null;
        checkboxes.forEach((item) => {
            if (item.checked) {
                interaction = item;
            }
        });
        return interaction;
    }

    // Enable rotation of the cube and update the interaction coords
    function SetupRotation(e) {
        e.preventDefault();
        e.stopPropagation();

        mouseX=e.clientX || e.touches[0].clientX;
        mouseY=e.clientY || e.touches[0].clientY;

        // Start rotating if right click is pressed and left is not
        if (e.buttons & (1 << 1) && !(e.buttons & (1 << 0))) {
            mouseDown = true;
        }
        // Conditionally rotate if its a touch (neither of the cube interactions are active)
        else if (e.type == "touchstart" && GetCubeInteraction() == null) {
            mouseDown = true;
        }
        // Conditionally rotate if its a left click (neither of the cube interactions are active)
        else if (e.buttons == 1 && GetCubeInteraction() == null) {
            mouseDown = true;
        }
        // Stop rotating if both left and right click is pressed
        else if (e.buttons & (1 << 1) && (e.buttons & (1 << 0))) {
            if (GetCubeInteraction() != null) {
                mouseDown = false;
            }
        }
    }

    // Disable rotation of the cube
    function StopRotation() {
        mouseDown = false;
    }

    // Rotate the cube if enabled
    function RotateCube(e) {

        if (mouseDown) {
            // Get the previous rotation values
            var [rotateX, rotateY, rotateZ] = container.style.transform.split(" ");
            var xRad = Number(rotateX.substring(rotateX.indexOf("(")+1, rotateX.indexOf("rad")));
            var yRad = Number(rotateY.substring(rotateY.indexOf("(")+1, rotateY.indexOf("rad")));
            var zRad = Number(rotateZ.substring(rotateZ.indexOf("(")+1, rotateZ.indexOf("rad")));

            // Get the values to apply to the rotation
            var newX = (((e.clientX || e.touches[0].clientX)-mouseX)/180)%(2*Math.PI);
            var newY = (((e.clientY || e.touches[0].clientY)-mouseY)/180)%(2*Math.PI);
            var newZ = 0;

            // Calculate the 3x3 rotation matrix (minus the unused r22 and r23)
            var r11 = Math.cos(newY) * Math.cos(newZ);
            var r12 = (Math.sin(newX) * Math.sin(newY) * Math.cos(newZ)) - (Math.cos(newX) * Math.sin(newZ));
            var r13 = (Math.cos(newX) * Math.sin(newY) * Math.cos(newZ)) + (Math.sin(newX) * Math.sin(newY));
            var r21 = Math.cos(newY) * Math.sin(newZ);
            var r31 = -Math.sin(newY);
            var r32 = Math.sin(newX) * Math.cos(newY);
            var r33 = Math.cos(newX) * Math.cos(newZ);

            // Calculate the (x,y) rotation into (x,y,z) terms
            if (Math.abs(r31) != 1) {
                newX = r31;
                newY = Math.atan2(r32 / Math.cos(r31), r33 / Math.cos(r31));
                newZ = Math.atan2(r21 / Math.cos(r31), r11 / Math.cos(r31));
            } else {
                newZ = 0;
                if (r31 == -1) {
                    newX = Math.PI / 2.0;
                    newY = Math.atan2(r12, r13);
                } else {
                    newX = -Math.PI / 2.0;
                    newY = Math.atan2(r12, -r13);
                }
            }

            // Apply the rotation
            container.style.transform = `rotateX(${xRad + newX}rad) rotateY(${yRad + newY}rad) rotateZ(${zRad + newZ}rad)`;

            // Update the last interaction coord
            mouseX=e.clientX || e.touches[0].clientX;
            mouseY=e.clientY || e.touches[0].clientY;
        }
    }

    function Interaction() {
        if (GetCubeInteraction() == null) {
            return;
        } else if (GetCubeInteraction().id == "Paint") {
            if (this.parentElement.value == "Paint") {
                this.parentElement.value = "";
            } else {
                this.parentElement.value = "Paint";
            }
        } else if (GetCubeInteraction().id == "Destroy") {
            Destroy.call(this);
        }
    }

    // Destroy the box that was clicked
    function Destroy() {
        // Get the box indeces
        var parent = this.parentElement;
        var [x, y, z] = parent.id.split(" ");
        x = Number(x);
        y = Number(y);
        z = Number(z);

        // Don't break the box if it was painted
        if (parent.value == "Paint") {
            return;
        }
        
        // For the 3x3 grid centered on the box, make it visible
        for (i of [1, -1]) {
            var xElement = document.getElementById((x+i) + " " + y + " " + z);
            if (xElement != null) {
                xElement.style.visibility = "visible";
            }
            var yElement = document.getElementById(x + " " + (y+i) + " " + z);
            if (yElement != null) {
                yElement.style.visibility = "visible";
            }
            var zElement = document.getElementById(x + " " + y + " " + (z+i));
            if (zElement != null) {
                zElement.style.visibility = "visible";
            }
        }

        // Remove the box
        parent.remove();
    }
</script>
</body>
</html>
