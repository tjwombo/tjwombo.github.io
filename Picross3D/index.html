<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="mystyle.css">
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <title>Level Editor</title>
</head>

<body onresize="WindowResize()" oncontextmenu="return false;"
        onmousedown="SetupRotation(event)" ontouchstart="SetupRotation(event)"
        onmouseup="ResetUserEvents()" onmouseleave="ResetUserEvents()" ontouchend="ResetUserEvents()" ontouchcancel="ResetUserEvents()"
        onmousemove="RotateCube(event); MoveSlider(event)" ontouchmove="if (lastUpdateCall != null) {cancelAnimationFrame(lastUpdateCall);} lastUpdateCall=window.requestAnimationFrame(() => {RotateCube(event)}); MoveSlider(event)">
    <div class="board" id="board">
        <div class="container" id="container">

        </div>
    </div>
    <div id="buttons" class="button" onmousedown="StopDrag(event)" >
        <button id="Add" onclick="LimitOne(this)" ontouchstart="LimitOne(this)">Add</button>
        <button id="Paint" onclick="LimitOne(this)" ontouchstart="LimitOne(this)">Paint</button>
        <button id="Destroy" onclick="LimitOne(this)" ontouchstart="LimitOne(this)">Destroy</button>
    </div>
    <div id="colors">
        <button id = "White" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="255" data-g="255" data-b="255" data-texture = "" class="clicked">White</button>
        <button id = "Black" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="0" data-g="0" data-b="0" data-texture = "">Black</button>
        <button id = "Gray" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="169" data-g="169" data-b="169" data-texture = "">Gray</button>
        <button id = "Red" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="255" data-g="0" data-b="0" data-texture = "">Red</button>
        <button id = "Orange" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="255" data-g="165" data-b="0" data-texture = "">Orange</button>
        <button id = "Yellow" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="255" data-g="255" data-b="0" data-texture = "">Yellow</button>
        <button id = "Lime" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="50" data-g="205" data-b="50" data-texture = "">Lime</button>
        <button id = "Green" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="0" data-g="128" data-b="0" data-texture = "">Green</button>
        <button id = "Cyan" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="0" data-g="255" data-b="255" data-texture = "">Cyan</button>
        <button id = "Blue" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="0" data-g="0" data-b="255" data-texture = "">Blue</button>
        <button id = "Purple" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="128" data-g="0" data-b="128" data-texture = "">Purple</button>
        <button id = "Pink" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="255" data-g="192" data-b="203" data-texture = "">Pink</button>
        <button id = "Tan" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="245" data-g="222" data-b="179" data-texture = "">Tan</button>
        <button id = "Brown" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="139" data-g="69" data-b="19" data-texture = "">Brown</button>
        <button id = "Maroon" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="128" data-g="0" data-b="0" data-texture = "">Marron</button>
        <button id = "Eye" onclick="SelectColor(this); ontouchstart=SelectColor(this)" data-r="255" data-g="255" data-b="255" data-texture = ".\base_1.svg">Eye</button>
    </div>
    <div id="maxDim">
    </div>
    
<script>
    // Size = %vmin dimensions of each box, xSize = # of boxes left-right, ySize = # of boxes top-down, zSize = # of boxes front-back
    const size = 5.5;
    const sliderSize = size*1.5;
    var xSize = 5;
    var ySize = 8;
    var zSize = 6;

    // List of boxes to avoid re-querying div.boxes everytime I need it
    const boxes = [[[]]];

    // Flag to seperate editing/puzzle solving and variables related to editing
    const isEditing = false;
    var colorR = "";
    var colorG = "";
    var colorB = "";
    var texture = ""; // STILL NEED TO SET UP THE TEXTURE
    if (!isEditing) {
        // Maybe eventually read from database options what color highlighting should be
        colorR = "0";
        colorG = "128";
        colorB = "0";
        document.getElementById("Add").remove();
        document.getElementById("maxDim").remove();
        document.getElementById("colors").remove();
    } else {
        colorR = "255";
        colorG = "255";
        colorB = "255";
        document.getElementById("colors").style.visibility = "hidden";
    }

    // Variables to represent color of unpainted boxes
    const unselectedR = 128;
    const unselectedG = 128;
    const unselectedB = 128;

    // Last used position of interaction point and if we should think about rotating
    var mouseX;
    var mouseY;
    var mouseDown = false;

    // Different mouse click variable to see if an interaction is held and should propogate the interaction and the axis to propogate on
    var held = false;
    var heldDelay = false;
    var axis = "";
    var faceAxis = ""; // Special variable for add blocks

    // Interaction variables to determine what interaction is selected
    var interaction = "";
    var painting = false; // For the paint interaction only have it go from off->on or vice versa
    var destroyBox = ""; // What box is exploding, so we don't re-explode the box

    // Slider variables to determine which slider is selected and the depth we are hiding
    var sliderPressed = "";
    var hideX = 0;
    var hideZ = 0;

    // Variable to hold last animation frame and cancel if needed
    var lastUpdateCall=null;

    // Position the cube to the center of the screen
    WindowResize();

    // Set the transformation origin the center of the cube and set the initial rotation
    var container = document.getElementById("container");
    container.style.transformOrigin = (size*xSize)/2.0 + "vmin " + (size*ySize)/2.0 +"vmin " + (size*zSize)/2.0 +"vmin";
    container.style.transform = "rotateX(-" + Math.PI/6 + "rad) rotateY(-" + Math.PI/6 + "rad) rotateZ(0rad)";

    // Read the puzzle information
    var frontHint = []
    var sideHint = []
    var topHint = []
    const puzzleFront = "0 0 - - 0|- 2 - 1 0|- 2 - - 0|- 3 - 4 -|1 4 - - 0|- 3 - - 1|1 1 - - -|1 0 - 1 0";
    const puzzleSide = "- - 1 - - -|- - 2 2 - -|- 0 2 2 - -|0 2 3 3 - 1|- 3 3 3 - -|1 4 3 3 - -|0 4 2 1 1 0|- 1 - - - -";
    const puzzleTop = "1 1 0 1 -|2 - 4 4C -|- - 7 4 -|- - 5 4 -|0 - 0 3C 0|0 - 0 1 -";
    const puzzleAnswer = [
                            [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0]],
                            [[0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]],
                            [[0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0]],
                            [[0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 1, 0]],
                            [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
                        ];
    console.log(puzzleAnswer);
    var frontAnswer = []
    var sideAnswer = []
    var topAnswer = []
    ParsePuzzle();
   
    // Create the cubes
    for (i = 0; i < xSize; i++) {
        for (j = 0; j < ySize; j++) {
            for (k = 0; k < zSize; k++) {
                var box = CreateBox(i, j, k);

                // Hide boxes that can't be see to save performance
                if ((i != 0 && i != xSize - 1) && (j != 0 && j != ySize - 1) && (k != 0 && k != zSize - 1)) {
                    box.style.visibility = "hidden";
                    box.dataset.region = "inner";
                }

                boxes[i][j].push(box);
            }
            if (j != ySize-1) {
                boxes[i].push([]);
            }
        }
        if (i != xSize-1) {
            boxes.push([[]]);
        }
    }

    // Create the slider objects
    var redSlider = CreateSlider(xSize, -1.5, true);
    var blueSlider = CreateSlider(-1, zSize+0.5, false);

    // Perform initial update of maxDim
    if (isEditing) {
        document.getElementById("maxDim").innerHTML = xSize + " " + ySize + " " + zSize;
    }


    // Reposition the cube when the window gets resized
    function WindowResize() {
        let w = document.documentElement.clientWidth;
        let h = document.documentElement.clientHeight;
        var board = document.getElementById("board");

        // Convert the larger to the smaller % to match the vmin of size
        if (w > h) {
            board.style.left = ((((w*100/h)/size) - xSize) / 2) * size + "vh";
            board.style.top = (((100.0/size) - ySize) / 2) * size + "vh";
        } else {
            board.style.left = (((100.0/size) - xSize) / 2) * size + "vw";
            board.style.top = ((((h*100/w)/size) - ySize) / 2) * size + "vw";
        }
    }

    // Change the shown dimensions by deltaX, deltaZ 
    function ChangeDimensions(deltaX, deltaZ) {
        // Move in the direction
        hideX += deltaX;
        hideZ += deltaZ;

        // Adjust the brightness for each box
        boxes.forEach((i) => {
            i.forEach((j) => {
                j.forEach((box) => {
                    ChangeBoxBrightness(box);
                })
            })
        });
    }

    // Change the brightness of the box based off of the current depth
    function ChangeBoxBrightness(box) {
        // Calculate the index in the id we care about, the direction, and the depth we are at, and the axis that is fully shown
        var index = 0;
        var sign = 1;
        var currentDepth;
        var axis = new RegExp(". . .");
        if (hideX < 0) {
            sign = -1;
            currentDepth = xSize + hideX;
            if (currentDepth < 0) {
                currentDepth = 0;
                hideX += 1;
            }
            axis = new RegExp(currentDepth + " . .");
        } else if (hideZ < 0) {
            index = 2;
            sign = -1;
            currentDepth = zSize + hideZ;
            if (currentDepth < 0) {
                currentDepth = 0;
                hideZ += 1;
            }
            axis = new RegExp(". . " + currentDepth);
        } else if (hideX > 0) {
            currentDepth = hideX - 1;
            if (currentDepth > xSize-1) {
                currentDepth = xSize-1;
                hideX -= 1;
            }
            axis = new RegExp(currentDepth + " . .");
        } else if (hideZ > 0) {
            index = 2;
            currentDepth = hideZ - 1;
            if (currentDepth > zSize-1) {
                currentDepth = zSize-1;
                hideZ -= 1;
            }
            axis = new RegExp(". . " + currentDepth);
        }

        // On match, show all boxes at normal colors
        if (box.id.search(axis) != -1) {
            if (box.dataset.modifier == "Paint" || box.dataset.modifier == "Permanent") {
                box.style.backgroundColor = "rgb(" + box.dataset.colorR + ", " + box.dataset.colorG + ", " + box.dataset.colorB + ")";
            } else {
                box.style.backgroundColor = "rgb(" + unselectedR + ", " + unselectedG + ", " + unselectedB + ")";
            }
            box.style.visibility = "visible";
        } else {
            // If we are 'behind' make it hidden
            if (parseInt(box.id.split(" ")[index])*sign < currentDepth*sign) {
                box.style.visibility = "hidden";
            } else {
                // Otherwise show the outer layer in a darker color
                if (box.dataset.region == "outer") {
                    box.style.visibility = "visible";
                    if (box.dataset.modifier == "Paint" || box.dataset.modifier == "Permanent") {
                        box.style.backgroundColor = "rgb(" + (Number(box.dataset.colorR)/2) + ", " + (Number(box.dataset.colorG)/2) + ", " + (Number(box.dataset.colorB)/2) + ")";
                    } else {
                        box.style.backgroundColor = "rgb(" + (Number(unselectedR)/2) + ", " + (Number(unselectedG)/2) + ", " + (Number(unselectedB)/2) + ")";
                    }
                } else {
                    box.style.visibility = "hidden";
                }
            }
        }
    }

    // Reset the brightness on all the boxes
    function ResetBrightness() {
        boxes.forEach((i) => {
            i.forEach((j) => {
                j.forEach((box) => {
                    if (box.dataset.modifier == "Paint" || box.dataset.modifier == "Permanent") {
                        box.style.backgroundColor = "rgb(" + box.dataset.colorR + ", " + box.dataset.colorG + ", " + box.dataset.colorB + ")";
                    } else {
                        box.style.backgroundColor = "rgb(" + unselectedR + ", " + unselectedG + ", " + unselectedB + ")";
                    }
                })
            })
        });
    }

    // Seperate the serialized puzzle info into a format each face can read to apply the puzzle information
    function ParsePuzzle() {
        frontHint = puzzleFront.split("|");
        for (let i = 0; i < frontHint.length; i++) {
            frontHint[i] = frontHint[i].split(" ");
            for (let j = 0; j < frontHint[i].length; j++) {
                frontHint[i][j] = InfoToImage(frontHint[i][j]);
            }
        }

        sideHint = puzzleSide.split("|");
        for (let i = 0; i < sideHint.length; i++) {
            sideHint[i] = sideHint[i].split(" ");
            for (let j = 0; j < sideHint[i].length; j++) {
                sideHint[i][j] = InfoToImage(sideHint[i][j]);
            }
        }

        topHint = puzzleTop.split("|");
        for (let i = 0; i < topHint.length; i++) {
            topHint[i] = topHint[i].split(" ");
            for (let j = 0; j < topHint[i].length; j++) {
                topHint[i][j] = InfoToImage(topHint[i][j]);
            }
        }
    }

    // Take the string info and turn it into the url string for the texture
    function InfoToImage(info) {
        if (info == "0") {
            return "./src/base_0.svg"
        } else if (info == "1") {
            return "./src/base_1.svg"
        } else if (info == "2") {
            return "./src/base_2.svg"
        } else if (info == "3") {
            return "./src/base_3.svg"
        } else if (info == "4") {
            return "./src/base_4.svg"
        } else if (info == "5") {
            return "./src/base_5.svg"
        } else if (info == "6") {
            return "./src/base_6.svg"
        } else if (info == "7") {
            return "./src/base_7.svg"
        } else if (info == "8") {
            return "./src/base_8.svg"
        } else if (info == "9") {
            return "./src/base_9.svg"
        } else if (info == "10") {
            return "./src/base_10.svg"
        } else if (info == "1C") {
            return "./src/circle_1.svg"
        } else if (info == "2C") {
            return "./src/circle_2.svg"
        } else if (info == "3C") {
            return "./src/circle_3.svg"
        } else if (info == "4C") {
            return "./src/circle_4.svg"
        } else if (info == "5C") {
            return "./src/circle_5.svg"
        } else if (info == "6C") {
            return "./src/circle_6.svg"
        } else if (info == "7C") {
            return "./src/circle_7.svg"
        } else if (info == "8C") {
            return "./src/circle_8.svg"
        } else if (info == "1S") {
            return "./src/square_1.svg"
        } else if (info == "2S") {
            return "./src/square_2.svg"
        } else if (info == "3S") {
            return "./src/square_3.svg"
        } else if (info == "4S") {
            return "./src/square_4.svg"
        } else if (info == "5S") {
            return "./src/square_5.svg"
        } else if (info == "6S") {
            return "./src/square_6.svg"
        } else if (info == "7S") {
            return "./src/square_7.svg"
        } else {
            return "./src/blank.svg"
        }
    }

    // Create a face of the cube and attach the event handlers where interactive = puzzle box and !Interactive = box created for explosion
    function CreateBoxFace(faceSize = size, interactive = true) {
        var face = document.createElement("div");
        face.style.width = `${faceSize-0.1}vmin`;
        face.className = "face";

        // Add the event listeners to the puzzle boxes
        if (interactive) {
            face.style.backgroundSize =  `${faceSize-1}vmin`;
            face.addEventListener("mousedown", Interaction);
            face.addEventListener("touchstart", Interaction)
            face.addEventListener("mousedown", (e) => {StopDrag(e, true)});
            face.addEventListener("mouseenter", ContinueInteraction);
            face.addEventListener("touchmove", (e) => {MobileMoveCheck(e)});
            face.addEventListener('touchend',  () => {held = false}); // Mobile destruction does not like to reset held, so we do it here
        } else {
            face.style.backgroundSize =  `${3*(faceSize-1)}vmin`;
        }

        return face;
    }

    // Create a box and its faces where left and top position represents the position of the background image on a face rather than the box position
    function CreateBox(i, j, k, boxSize = size, interactive = true, leftPosition = 0, topPosition = 0) {
        // Create and position the box
        var box = document.createElement("div");
        box.className = "box";
        box.style.width = `${boxSize}vmin`;
        box.style.left = `${size*(i)}vmin`
        box.style.top = `${size*(j)}vmin`;
        box.style.transform = "translateZ(" + size*(k) + "vmin)";
        box.style.backgroundColor = "rgb(" + unselectedR + ", " + unselectedG + ", " + unselectedB + ")";
        box.id = i + " " + j + " " + k;
        box.dataset.region = "outer";
        if (!isEditing && interactive && puzzleAnswer[i][j][k]) {
            box.dataset.required = "Required";
        }
        container.appendChild(box);

        // Create the top face
        var topFace = CreateBoxFace(boxSize, interactive);
        topFace.style.transform = "rotateX(90deg) translateZ(" + 0.5 * boxSize + "vmin)";
        if (!interactive) {
            topFace.style.backgroundPosition = leftPosition + "% " + topPosition + "%";
        }
        if (!isEditing) {
            topFace.style.backgroundImage = 'url(' + topHint[Math.round(k)][Math.floor(i)] + ')';
        }
        topFace.id = "top";
        box.appendChild(topFace);

        // Create the bottom face
        var bottom = CreateBoxFace(boxSize, interactive)
        bottom.style.transform = "rotateX(-90deg) translateZ(" + 0.5 * boxSize + "vmin)";
        if (!interactive) {
            bottom.style.backgroundPosition = leftPosition + "% " + topPosition + "%";
        }
        if (!isEditing) {
            bottom.style.backgroundImage = 'url(' + topHint[Math.round(k)][Math.floor(i)] + ')';
        }
        bottom.id = "bottom";
        box.appendChild(bottom);

        // Create the back face
        var back = CreateBoxFace(boxSize, interactive);
        back.style.transform = "rotateY(180deg) translateZ(" + 0.5 * boxSize + "vmin)";
        if (!interactive) {
            back.style.backgroundPosition = leftPosition + "% " + topPosition + "%";
        }
        if (!isEditing) {
            back.style.backgroundImage = 'url(' + frontHint[Math.floor(j)][Math.floor(i)] + ')';
        }
        back.id = "back";
        box.appendChild(back);

        // Create the front face
        var front = CreateBoxFace(boxSize, interactive);
        front.style.transform = "translateZ(" + 0.5 * boxSize + "vmin)";
        if (!interactive) {
            front.style.backgroundPosition = leftPosition + "% " + topPosition + "%";
        }
        if (!isEditing) {
            front.style.backgroundImage = 'url(' + frontHint[Math.floor(j)][Math.floor(i)] + ')';
        }
        front.id = "front";
        box.appendChild(front);

        // Create the left face
        var left = CreateBoxFace(boxSize, interactive);
        left.style.transform = "rotateY(-90deg) translateZ(" + 0.5 * boxSize + "vmin)";
        if (!interactive) {
            left.style.backgroundPosition = leftPosition + "% " + topPosition + "%";
        }
        if (!isEditing) {
            left.style.backgroundImage = 'url(' + sideHint[Math.floor(j)][Math.round(k)] + ')';
        }
        left.id = "left";
        box.appendChild(left);

        // Create the right face
        var right = CreateBoxFace(boxSize, interactive);
        right.style.transform = "rotateY(90deg) translateZ(" + 0.5 * boxSize + "vmin)";
        if (!interactive) {
            right.style.backgroundPosition = leftPosition + "% " + topPosition + "%";
        }
        if (!isEditing) {
            right.style.backgroundImage = 'url(' + sideHint[Math.floor(j)][Math.round(k)] + ')';
        }
        right.id = "right";
        box.appendChild(right);

        return box;
    }

    // Create a side of the slider and attach the event handlers
    function CreateSliderSide(changesX) {
        var side = document.createElement("div");
        side.style.borderWidth =  (sliderSize/4.0) +'vmin';
        side.style.borderBottomWidth = (sliderSize/2.0) + 'vmin'; 
        side.className = "side";
        if (changesX) {
            side.style.borderBottomColor = "rgb(255, 0, 0)";
        } else {
            side.style.borderBottomColor = "rgb(0, 0, 255)";
        }

        side.addEventListener("mousedown", (e) => {StopDrag(e)});
        side.addEventListener("mousedown", (e) => {SetupSlider(e, side)});
        side.addEventListener("touchstart", (e) => {StopDrag(e)});
        side.addEventListener("touchstart", (e) => {SetupSlider(e, side)});

        return side;
    }

    // Create the slider object and its sides
    function CreateSlider(xIndex, zIndex, changesX) {
        // Create the slider object
        var slider = document.createElement("div");
        slider.className = "slider";
        slider.style.width = `${sliderSize}vmin`;
        slider.style.left = `${size*(xIndex)}vmin`
        slider.style.top = `${size*(ySize/2)}vmin`;

        // set the directions each slider manipulates and rotate the red slider to be horizontal
        if (changesX) {
            slider.style.transform = "translateZ(" + size*(zIndex) + "vmin) RotateZ(90deg) RotateY(45deg)";
            slider.id = "slider red";
            slider.dataset.xDirection = -1;
            slider.dataset.zDirection = 0;
        } else {
            slider.style.transform = "translateZ(" + size*(zIndex) + "vmin)";
            slider.id = "slider blue";
            slider.dataset.xDirection = 0;
            slider.dataset.zDirection = -1;
        }
        container.appendChild(slider);

        // Create the top front face
        var topFront = CreateSliderSide(changesX);
        topFront.style.transform = "translateZ(" + (sliderSize/4) + "vmin) rotateX(30deg)";
        topFront.id = "top front";
        slider.appendChild(topFront);

        // Create the top right face
        var topRight = CreateSliderSide(changesX)
        topRight.style.transform = "translateX(" + (sliderSize/8) + "vmin) translateZ(" + (sliderSize/8) + "vmin) rotateY(90deg) rotateX(30deg)";
        topRight.id = "top right";
        slider.appendChild(topRight);

        // Create the top left face
        var topLeft = CreateSliderSide(changesX);
        topLeft.style.transform = "translateX(" + (-sliderSize/8) + "vmin) translateZ(" + (sliderSize/8) + "vmin) rotateY(270deg) rotateX(30deg)";
        topLeft.id = "top left";
        slider.appendChild(topLeft);

        // Create the top back face
        var topBack = CreateSliderSide(changesX);
        topBack.style.transform = "rotateX(-30deg) rotateY(180deg)";
        topBack.id = "top back";
        slider.appendChild(topBack);

        // Create the bottom front face
        var bottomFront = CreateSliderSide(changesX);
        bottomFront.style.transform = "translateY(" + (sliderSize*Math.sqrt(3)/4) + "vmin) translateZ(" + (sliderSize/4) + "vmin) rotateX(-30deg) rotateZ(180deg)";
        bottomFront.id = "bottom front";
        slider.appendChild(bottomFront);

        // Create the bottomm right face
        var bottomRight = CreateSliderSide(changesX)
        bottomRight.style.transform = "translateX(" + (sliderSize/8) + "vmin) translateY(" + (sliderSize*Math.sqrt(3)/4) + "vmin) translateZ(" + (sliderSize/8) + "vmin) rotateY(90deg) rotateX(-30deg) rotateZ(180deg)";
        bottomRight.id = "bottom right";
        slider.appendChild(bottomRight);

        // Create the bottom left face
        var bottomLeft = CreateSliderSide(changesX);
        bottomLeft.style.transform = "translateX(" + (-sliderSize/8) + "vmin) translateY(" + (sliderSize*Math.sqrt(3)/4) + "vmin) translateZ(" + (sliderSize/8) + "vmin) rotateY(270deg) rotateX(-30deg) rotateZ(180deg)";
        bottomLeft.id = "bottom left";
        slider.appendChild(bottomLeft);

        // Create the bottom back face
        var bottomBack = CreateSliderSide(changesX);
        bottomBack.style.transform = "translateY(" + (sliderSize*Math.sqrt(3)/4) + "vmin) rotateX(30deg) rotateY(180deg) rotateZ(180deg)";
        bottomBack.id = "bottom back";
        slider.appendChild(bottomBack);

        return slider;
    }

    // For mobile find the box with the greatest actual z position to perform the interaction on as there is no mouse enter equivalent
    function MobileMoveCheck(e) {
        // Make sure there is an interaction
        if (interaction == "") {
            return;
        }

        // Array with boxes that were touched and its z position
        var touchedBoxes = []

        boxes.forEach((i) => {
            i.forEach((j) => {
                j.forEach((box) => {
                    // Skip over boxes that can't be selected
                    if (box.style.visibility != "hidden") {
                        // Check if the touch point is inside the bounding box for any of the faces
                        for (var i = 0; i < box.children.length; i++) {
                            var item = box.children[i];
                            if ((
                                (e.touches[0].clientX >= item.getBoundingClientRect().left && e.touches[0].clientX <= item.getBoundingClientRect().right) &&
                                (e.touches[0].clientY >= item.getBoundingClientRect().top  && e.touches[0].clientY <= item.getBoundingClientRect().bottom)
                            )) {
                                // Add to the array and break, as we care about the box not the face
                                var [_, _, boxZ] = CalculatePosition(box);
                                touchedBoxes.push([boxZ, box]);
                                break;
                            }
                        }
                    }
                })
            })
        });

        // If we have at least one box, find the box with the greatest z and call the interaction on it
        if (touchedBoxes.length > 0) {
            maxZ = touchedBoxes[0][0];
            maxBox = touchedBoxes[0][1];
            for (var i = 0; i < touchedBoxes.length; i++) {
                if (touchedBoxes[i][0] > maxZ) {
                    maxZ = touchedBoxes[i][0];
                    maxBox = touchedBoxes[i][1];
                }
            }
            ContinueInteraction.call(maxBox.childNodes[0]);
        }
    }

    // Calculate the real position of the box with respect to origin and with rotation
    function CalculatePosition(box) {
        // Turn the origin into floats
        var [originX, originY, originZ] = container.style.transformOrigin.split(" ");
        if (originX == undefined) {
            originX = 0;
        } else {
            originX = parseFloat(originX.substring(0, originX.indexOf("vmin")));
        }
        if (originY == undefined) {
            originY = 0;
        } else {
            originY = parseFloat(originY.substring(0, originY.indexOf("vmin")));
        }
        if (originZ == undefined) {
            originZ = 0;
        } else {
            originZ = parseFloat(originZ.substring(0, originZ.indexOf("vmin")));
        }
        // Turn the rotation into floats
        var [rotateX, rotateY, rotateZ] = container.style.transform.split(" ");
        if (rotateX == undefined) {
            rotateX = 0;
        } else {
            rotateX = parseFloat(rotateX.substring(rotateX.indexOf("rotateX")+8, rotateX.indexOf("rad")));
        }
        if (rotateY == undefined) {
            rotateY = 0;
        } else {
            rotateY = parseFloat(rotateY.substring(rotateY.indexOf("rotateY")+8, rotateY.indexOf("rad")));
        }
        if (rotateZ == undefined) {
            rotateZ = 0;
        } else {
            rotateZ = parseFloat(rotateZ.substring(rotateZ.indexOf("rotateZ")+8, rotateZ.indexOf("rad")));
        }

        // Matrix multiplication values
        var cosa = Math.cos(rotateZ);
        var sina = Math.sin(rotateZ);

        var cosb = Math.cos(rotateX);
        var sinb = Math.sin(rotateX);

        var cosc = Math.cos(rotateY);
        var sinc = Math.sin(rotateY);

        var Axx = cosa*cosb;
        var Axy = cosa*sinb*sinc - sina*cosc;
        var Axz = cosa*sinb*cosc + sina*sinc;

        var Ayx = sina*cosb;
        var Ayy = sina*sinb*sinc + cosa*cosc;
        var Ayz = sina*sinb*cosc - cosa*sinc;

        var Azx = -sinb;
        var Azy = cosb*sinc;
        var Azz = cosb*cosc;

        // Get the float value of the box x, y, and z
        var px = box.style.left;
        var py = box.style.top;
        var pz = box.style.transform;
        if (px == undefined) {
            px = 0;
        } else {
            px = parseFloat(px.substring(0, px.indexOf("vmin")));
        }
        if (py == undefined) {
            py = 0;
        } else {
            py = parseFloat(py.substring(0, py.indexOf("vmin")));
        }
        if (pz == undefined) {
            pz = 0;
        } else {
            pz = parseFloat(pz.substring(pz.indexOf("translateZ")+11, pz.indexOf("vmin")));
        }

        // Calculate the new positions with respect to origin
        px -= originX;
        py -= originY;
        pz -= originZ;
        var newX = Axx*px + Axy*py + Axz*pz + originX;
        var newY = Ayx*px + Ayy*py + Ayz*pz + originY;
        var newZ = Azx*px + Azy*py + Azz*pz + originZ;

        return [newX, newY, newZ];
    }

    // Stop Rotation from being setup when mouse goes down on a click event object
    function StopDrag(e, conditionally = false) {
        // If we want to allow drag while we don't have a cube interaction
        if ((conditionally && interaction == "") || (e.buttons & (1 << 1) && !(e.buttons & (1 << 0)))) {
            return true;
        }

        e.stopPropagation();
    }

    // Limit interaction buttons to only have one clicked at a time
    // Could probably be reworked to be similar to the newer SelectColor
    function LimitOne(button) {
        if (button.id == "Paint") {
            if (interaction == "Paint") {
                interaction = "";
                button.classList.remove("clicked");
                if (isEditing) {
                    document.getElementById("colors").style.visibility = "hidden";
                }
            } else {
                interaction = "Paint";
                button.classList.add('clicked');
                document.getElementById("Destroy").classList.remove("clicked");
                if (isEditing) {
                    document.getElementById("Add").classList.remove("clicked");
                    document.getElementById("colors").style.visibility = "visible";
                }
            }
        } else if (button.id == "Destroy") {
            if (interaction == "Destroy") {
                interaction = "";
                button.classList.remove("clicked");
            } else {
                interaction = "Destroy";
                button.classList.add("clicked");
                document.getElementById("Paint").classList.remove("clicked");
                if (isEditing) {
                    document.getElementById("Add").classList.remove("clicked");
                }
            }
            if (isEditing) {
                document.getElementById("colors").style.visibility = "hidden";
            }
        } else if (button.id == "Add") {
            if (interaction == "Add") {
                interaction = "";
                button.classList.remove("clicked");
            } else {
                interaction = "Add";
                button.classList.add("clicked");
                document.getElementById("Paint").classList.remove("clicked");
                document.getElementById("Destroy").classList.remove("clicked");
            }
            document.getElementById("colors").style.visibility = "hidden";
        }
    }

    // Limit color buttons to only have one clicked at a time
    function SelectColor(button) {
        // Click the button that was clicked, and unclick all the other buttons
        document.getElementById("colors").childNodes.forEach((color) => {
            if (color.id == button.id) {
                color.className = "clicked";
            } else {
                color.className = "";
            }
        })

        // Update the rgb colors
        colorR = button.dataset.r;
        colorG = button.dataset.g;
        colorB = button.dataset.b;
    }

    // Enable rotation of the cube and update the interaction coords
    function SetupRotation(e) {
        // Prevent other events when we are rotating
        e.preventDefault();
        e.stopPropagation();

        // Get the 'mouse' coords
        if (e.touches != undefined) {
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        } else {
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        // Start rotating if right click is pressed and left is not
        if (e.buttons & (1 << 1) && !(e.buttons & (1 << 0))) {
            mouseDown = true;
        }
        // Conditionally rotate if its a touch (none of the cube interactions are active)
        else if (e.type == "touchstart" && interaction == "") {
            mouseDown = true;
        }
        // Conditionally rotate if its a left click (none of the cube interactions are active)
        else if (e.buttons == 1 && interaction == "") {
            mouseDown = true;
        }
        // Stop rotating if both left and right click is pressed
        else if (e.buttons & (1 << 1) && (e.buttons & (1 << 0))) {
            if (interaction != "") {
                mouseDown = false;
            }
        }
    }

    // Reset variables that were set through a user interaction
    function ResetUserEvents() {
        mouseDown = false;
        held = false;
        sliderPressed = "";


        // Brightness hack-ish where abs(1) does not hide anything, just outer brightness, so we need to reset it when we let go
        if (Math.abs(hideX) == 1) {
            hideX = 0;
            ResetBrightness();
            blueSlider.style.visibility = "visible"
        }
        if (Math.abs(hideZ) == 1) {
            hideZ = 0;
            ResetBrightness();
            redSlider.style.visibility = "visible"
        }

        // Show the both sliders if we're at full visibility
        if (hideX == 0 && hideZ == 0) {
            redSlider.style.visibility = "visible"
            blueSlider.style.visibility = "visible"
        }
    }

    // Rotate the cube if rotation is active
    function RotateCube(e) {
        // Check if we are rotating the cube
        if (mouseDown) {
            // Get the previous rotation values
            var [rotateX, rotateY, rotateZ] = container.style.transform.split(" ");
            var xRad = Number(rotateX.substring(rotateX.indexOf("(")+1, rotateX.indexOf("rad")));
            var yRad = Number(rotateY.substring(rotateY.indexOf("(")+1, rotateY.indexOf("rad")));
            var zRad = Number(rotateZ.substring(rotateZ.indexOf("(")+1, rotateZ.indexOf("rad")));

            // Get the new values to apply to the rotation
            var newX;
            var newY;
            if (e.touches != undefined) {
                newX = ((e.touches[0].clientX-mouseX)/180)%(2*Math.PI);
                newY = ((e.touches[0].clientY-mouseY)/180)%(2*Math.PI);
            } else {
                newX = ((e.clientX-mouseX)/180)%(2*Math.PI);
                newY = ((e.clientY-mouseY)/180)%(2*Math.PI);
            }
            var newZ = 0;

            // Calculate the 3x3 rotation matrix (minus the unused r22 and r23)
            var r11 = Math.cos(newY) * Math.cos(newZ);
            var r12 = (Math.sin(newX) * Math.sin(newY) * Math.cos(newZ)) - (Math.cos(newX) * Math.sin(newZ));
            var r13 = (Math.cos(newX) * Math.sin(newY) * Math.cos(newZ)) + (Math.sin(newX) * Math.sin(newY));
            var r21 = Math.cos(newY) * Math.sin(newZ);
            var r31 = -Math.sin(newY);
            var r32 = Math.sin(newX) * Math.cos(newY);
            var r33 = Math.cos(newX) * Math.cos(newZ);

            // Calculate the (x,y) rotation into (x,y,z) terms
            if (Math.abs(r31) != 1) {
                newX = r31;
                newY = Math.atan2(r32 / Math.cos(r31), r33 / Math.cos(r31));
                newZ = Math.atan2(r21 / Math.cos(r31), r11 / Math.cos(r31));
            } else {
                newZ = 0;
                if (r31 == -1) {
                    newX = Math.PI / 2.0;
                    newY = Math.atan2(r12, r13);
                } else {
                    newX = -Math.PI / 2.0;
                    newY = Math.atan2(r12, -r13);
                }
            }

            // Limit X rotation to 90 degrees
            if (xRad + newX > Math.PI/2) {
                xRad = Math.PI/2 - newX
            } else if (xRad + newX < -Math.PI/2) {
                xRad = -Math.PI/2 - newX;
            }

            // Apply the rotation
            container.style.transform = `rotateX(${(xRad + newX)}rad) rotateY(${(yRad + newY)%(2*Math.PI)}rad) rotateZ(${(zRad + newZ)%(2*Math.PI)}rad)`;

            // Update the last interaction coord
            if (e.touches != undefined) {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
            } else {
                mouseX = e.clientX;
                mouseY = e.clientY;
            }

            // Check to see if the sliders position needs to be updated (and update it if needed)
            SliderPositionUpdate(xRad + newX, yRad + newY, zRad + newZ);
            
        }

        lastUpdateCall=null;
    }

    // Change the position of the slider and the direction it scales in if needed
    function SliderPositionUpdate(xRad, yRad, zRad) {
        // Recenter the top position of the sliders (should only change if editing)
        redSlider.style.top = `${size*(ySize/2)}vmin`;
        blueSlider.style.top = `${size*(ySize/2)}vmin`;

        // Keep the slider position static if we are not at full visibility
        // SHOULD UPDATE IT TO ALLOW THE VISIBLE ONE TO CHANGE SIDE IF IT KEEPS THE SAME DIRECTION, BUT BLOCK A DIRECTION CHANGE ROTATION
        // ALSO PROBABLY COULD STRUCTURE IT BETTER
        if (hideX == 0 && hideZ == 0) {
            if (yRad < -Math.PI*3/2) {
                redSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                blueSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin)";
                blueSlider.dataset.zDirection = -1;
            } else if (yRad < -Math.PI) {
                redSlider.style.left = -size + "vmin";
                blueSlider.style.left = size*xSize + "vmin";
                blueSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin)";
                redSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                redSlider.dataset.xDirection = 1;
                blueSlider.dataset.zDirection = 1;
            } else if (yRad < -Math.PI/2) {
                blueSlider.style.left = -size + "vmin";
                redSlider.style.left = size*xSize + "vmin";
                blueSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin)";
                redSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                redSlider.dataset.xDirection = -1;
                blueSlider.dataset.zDirection = 1;
            } else if (yRad < 0) {
                blueSlider.style.left = -size + "vmin";
                redSlider.style.left = size*xSize + "vmin";
                redSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                blueSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin)";
                redSlider.dataset.xDirection = -1;
                blueSlider.dataset.zDirection = -1;
            }
            
            else if (yRad > Math.PI*3/2) {
                redSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                blueSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin)";
                blueSlider.dataset.zDirection = -1
            } else if (yRad > Math.PI) {
                blueSlider.style.left = -size + "vmin";
                redSlider.style.left = size*xSize + "vmin";
                blueSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin)";
                redSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                redSlider.dataset.xDirection = -1;
                blueSlider.dataset.zDirection = 1
            } else if (yRad > Math.PI/2) {
                redSlider.style.left = -size + "vmin";
                blueSlider.style.left = size*xSize + "vmin";
                blueSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin)";
                redSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                redSlider.dataset.xDirection = 1;
                blueSlider.dataset.zDirection = 1
            } else if (yRad > 0) {
                redSlider.style.left = -size + "vmin";
                blueSlider.style.left = size*xSize + "vmin";
                redSlider.style.transform = "translateZ(" + size*(-1.5) + "vmin) RotateZ(90deg) RotateY(45deg)";
                blueSlider.style.transform = "translateZ(" + size*(zSize + 0.5) + "vmin)";
                redSlider.dataset.xDirection = 1;
                blueSlider.dataset.zDirection = -1;
            }
        }
    }

    // Get the number of pixels from the Vh percent
    function getVh(percent) {
        var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        return (percent * h) / 100;
    }

    // Get the number of pixels from the Vw percent
    function getVw(percent) {
        var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        return (percent * w) / 100;
    }

    // Get the number of pixels from the Vmin percent
    // I DON'T PLAN ON USING THE OTHER TWO, SO MAYBE JUST COMBINE THEM INTO THIS ONE
    function getVmin(percent) {
        return Math.min(getVh(percent), getVw(percent));
    }

    // Setup the variables for the slider movement
    function SetupSlider(e, side) {
        sliderPressed = side.parentElement;

        if (e.touches != undefined) {
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        } else {
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        // Hide the other slider
        if (sliderPressed.id == "slider red") {
            blueSlider.style.visibility = "hidden";
        } else if (sliderPressed.id == "slider blue") {
            redSlider.style.visibility = "hidden";
        }

        // Redraw the box bright
        if (hideX != 0 || hideZ != 0) {
            // UNSURE WHAT THE PURPOSE OF THIS ONE IS ACTUALLY, COMMENTING THIS OUT DOESNT SEEM TO CHANGE ANYTHING
            ChangeDimensions(0, 0);
        }
        // If we were at full visiblity, perform the initial offset to darken the boxes behind
        else {
            ChangeDimensions(Number(sliderPressed.dataset.xDirection), Number(sliderPressed.dataset.zDirection));
        }
    };

    // Check if the slider needs to move and change the dimensions appropriately
    function MoveSlider(e) {
        // Make sure a slider is selected
        if (sliderPressed != "") {
            // Get the y rotation of the cube
            var [_, rotateY, _] = container.style.transform.split(" ");
            var yRad = Number(rotateY.substring(rotateY.indexOf("(")+1, rotateY.indexOf("rad")));

            var currentX;
            var currentY;
            if (e.touches != undefined) {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }

            // Calculate if the slider has changed size% vmin accounting for the cube rotation
            var redBlockDif = (mouseX - currentX)*(Math.cos(yRad))/getVmin(size) + (currentY - mouseY)*(Math.sin(yRad))/getVmin(size);
            var blueBlockDif = (mouseX - currentX)*(Math.sin(yRad))/getVmin(size) + (mouseY - currentY)*(Math.cos(yRad))/getVmin(size);

            // Check if the red slider is causing a dimension change
            if (redBlockDif*Number(sliderPressed.dataset.xDirection) <= -1) {
                // Change the dimension for each size% change
                for (let i = 0; i < Math.floor(Math.abs(redBlockDif)); i++) {
                    ChangeDimensions(Number(sliderPressed.dataset.xDirection), Number(sliderPressed.dataset.zDirection));

                    // Update the position
                    if (sliderPressed.dataset.xDirection == -1) {
                        redSlider.style.left = ((xSize+1-Math.abs(hideX))*size) + "vmin";
                    } else {
                        redSlider.style.left = ((Math.abs(hideX)-2)*size) + "vmin";
                    }
                }
                // Update the last accounted for mouse position
                if (e.touches != undefined) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                } else {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            } else if (redBlockDif*Number(sliderPressed.dataset.xDirection) >= 1) {
                for (let i = 0; i < Math.floor(Math.abs(redBlockDif)); i++) {
                    if (Math.abs(hideX) == 1) { // Prevent it from changing from pos->neg or vice versa
                        break;
                    } else {
                        ChangeDimensions(-Number(sliderPressed.dataset.xDirection), -Number(sliderPressed.dataset.zDirection));
                        if (sliderPressed.dataset.xDirection == -1) {
                            redSlider.style.left = ((xSize+1-Math.abs(hideX))*size) + "vmin";
                        } else {
                            redSlider.style.left = ((Math.abs(hideX)-2)*size) + "vmin";
                        }
                    }
                    if (e.touches != undefined) {
                        mouseX = e.touches[0].clientX;
                        mouseY = e.touches[0].clientY;
                    } else {
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                }
            }
            
            // Check if the blue slider is causing a dimension change
            else if (blueBlockDif*Number(sliderPressed.dataset.zDirection) <= -1) {
                for (let i = 0; i < Math.floor(Math.abs(blueBlockDif)); i++) {
                    ChangeDimensions(Number(sliderPressed.dataset.xDirection), Number(sliderPressed.dataset.zDirection));
                    if (sliderPressed.dataset.zDirection == -1) {
                        blueSlider.style.transform = "translateZ(" + size*(zSize + 1.5 - Math.abs(hideZ)) + "vmin)";
                    } else {
                        blueSlider.style.transform = "translateZ(" + size*(-2.5 + Math.abs(hideZ)) + "vmin)";
                    }
                }
                if (e.touches != undefined) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                } else {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            } else if (blueBlockDif*Number(sliderPressed.dataset.zDirection) >= 1) {
                for (let i = 0; i < Math.floor(Math.abs(blueBlockDif)); i++) {
                    if (Math.abs(hideZ) == 1) { // Prevent it from changing from pos->neg or vice versa
                        break;
                    } else {
                        ChangeDimensions(-Number(sliderPressed.dataset.xDirection), -Number(sliderPressed.dataset.zDirection));
                        if (sliderPressed.dataset.zDirection == -1) {
                            blueSlider.style.transform = "translateZ(" + size*(zSize + 1.5 - Math.abs(hideZ)) + "vmin)";
                        } else {
                            blueSlider.style.transform = "translateZ(" + size*(-2.5 + Math.abs(hideZ)) + "vmin)";
                        }
                    }
                    if (e.touches != undefined) {
                        mouseX = e.touches[0].clientX;
                        mouseY = e.touches[0].clientY;
                    } else {
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                }
            }
        }
    }

    // Perform a cube interaction and setup for continued interaction
    function Interaction() {
        // If there is no interaction return
        if (interaction == "") {
            return;
        }
        // Paint the cube
        else if (interaction == "Paint") {
            Paint.call(this);
        }
        // Destroy the cube
        else if (interaction == "Destroy") {
            Destroy.call(this);
        }
        // Add a cube
        else if (interaction == "Add") {
            AddBlock.call(this);
        }

        // If this is the first interaction of the click, set up the axis
        if (held == false) {
            held = true;
            heldDelay = true;
            axis = this.parentElement.id;
        }
    }

    // Continue a held interaction
    function ContinueInteraction() {
        // Check if an interaction should occur
        if (held) {
            // Create a delay before performing the first held interaction
            if (heldDelay) {
                // However, there is zero delay on paint
                if (interaction == "Paint") {
                    heldDelay = false;
                    ContinueInteraction.call(this);
                } else if (interaction == "Destroy") {
                    // Create a delay before accepting input
                    setTimeout(() => {
                        heldDelay = false;
                        // Create an additional delay before destroying the block that caused this
                        // This allows another block to be chosen as the first break
                        setTimeout(() => {
                            ContinueInteraction.call(this);
                        }, 100);
                    }, 100);
                } else if (interaction == "Add") {

                    // Set the axis parent to be the newly added block
                    var [pX, pY, pZ] = this.parentElement.id.split(" ");
                    axis = new RegExp(pX + " " + pY + " " + pZ);
                    faceAxis = ""

                    heldDelay = false;

                    // Create a delay before accepting input
                    setTimeout(() => {
                        // Create an additional delay before adding the block
                        // This allows another side to be chosen as the first add
                        setTimeout(() => {

                            // If we don't choose a different side first, create the setup
                            if (faceAxis == "")  {
                                var [pX, pY, pZ] = this.parentElement.id.split(" ");
                                if (this.id == "top" || this.id == "bottom") {
                                    faceAxis = "y";
                                    axis = new RegExp(pX + " . " + pZ);
                                } else if (this.id == "right" || this.id == "left") {
                                    faceAxis = "x";
                                    axis = new RegExp(". " + pY + " " + pZ);
                                } else if (this.id == "front" || this.id == "back") {
                                    faceAxis = "z";
                                    axis = new RegExp(pX + " " + pY + " .");
                                }
                                ContinueInteraction.call(this);
                            }
                        }, 100);
                    }, 100);
                }
            }
            // Held interactions after the initial delay
            else {
                var parent = this.parentElement.id

                // We've gotten the added block, but need to determine the direction to add in
                if (interaction == "Add" && faceAxis == "") {
                    if (parent.search(axis) != -1) {
                        var [pX, pY, pZ] = parent.split(" ");
                        if (this.id == "top" || this.id == "bottom") {
                            faceAxis = "y";
                            axis = new RegExp(pX + " . " + pZ);
                        } else if (this.id == "right" || this.id == "left") {
                            faceAxis = "x";
                            axis = new RegExp(". " + pY + " " + pZ);
                        } else if (this.id == "front" || this.id == "back") {
                            faceAxis = "z";
                            axis = new RegExp(pX + " " + pY + " .");
                        }
                    }
                }
                // If axis is a regex perform interaction if the box matches
                else if (typeof(axis) != "string") {
                    // Find the id of the would be new block and perform the search on that
                    if (interaction == "Add") {
                        var [pX, pY, pZ] = parent.split(" ");
                        if (this.id == "right" && ((Number(pX)+1) + " " + pY + " " + pZ).search(axis) != -1) {
                            Interaction.call(this);
                        } else if (this.id == "left" && ((Number(pX)-1) + " " + pY + " " + pZ).search(axis) != -1) {
                            Interaction.call(this);
                        } else if (this.id == "bottom" && (pX + " " + (Number(pY)+1) + " " + pZ).search(axis) != -1) {
                            Interaction.call(this);
                        } else if (this.id == "top" && (pX + " " + (Number(pY)-1) + " " + pZ).search(axis) != -1) {
                            Interaction.call(this);
                        } else if (this.id == "front" && (pX + " " + pY + " " + (Number(pZ)+1)).search(axis) != -1) {
                            Interaction.call(this);
                        } else if (this.id == "back" && (pX + " " + pY + " " + (Number(pZ)-1)).search(axis) != -1) {
                            Interaction.call(this);
                        }
                    }
                    // Otherwise do the normal search
                    else if (parent.search(axis) != -1) {
                        Interaction.call(this);
                    }
                }
                // Otherwise its the first face so create the regex where the difference is and call the interaction
                else {
                    var [aX, aY, aZ] = axis.split(" ");
                    var [pX, pY, pZ] = parent.split(" ");

                    if (aX != pX && aY == pY && aZ == pZ) {
                        axis = new RegExp(". " + aY + " " + aZ);
                    } else if (aY != pY && aX == pX && aZ == pZ) {
                        axis = new RegExp(aX + " . " + aZ);
                    } else if (aZ != pZ && aX == pX && aY == pY) {
                        axis = new RegExp(aX + " " + aY + " .");
                    }
                    // If there is at least two different, i.e. diagonal, dont do anything 
                    else {
                        return;
                    }

                    Interaction.call(this);
                }
            }
        }
    }

    // Toggle the paint modifier unless it has the perminent modifier
    function Paint() {
        var parent = this.parentElement
        // If we were held, perform the same paint interaction, unless its permanently painted
        if (held) {
            if (parent.dataset.modifier != "Permanent") {
                if (paint) {
                    parent.dataset.modifier = "Paint";
                    parent.style.backgroundColor = "rgb(" + colorR + ", " + colorG + ", " + colorB + ")";
                    parent.dataset.colorR = colorR;
                    parent.dataset.colorG = colorG;
                    parent.dataset.colorB = colorB;
                } else {
                    parent.dataset.modifier = "Destroy";
                    parent.style.backgroundColor = "rgb(" + unselectedR + ", " + unselectedG + ", " + unselectedB + ")";
                    parent.dataset.colorR = unselectedR;
                    parent.dataset.colorG = unselectedG;
                    parent.dataset.colorB = unselectedB;
                }
            }
        }
        // Otherwise toggle it
        else {
            // Toggle if its painted and the same color
            if (parent.dataset.modifier == "Paint" && parent.dataset.colorR == colorR && parent.dataset.colorG == colorG && parent.dataset.colorB == colorB) {
                parent.dataset.modifier = "Destroy";
                parent.style.backgroundColor = "rgb(" + unselectedR + ", " + unselectedG + ", " + unselectedB + ")";
                parent.dataset.colorR = unselectedR;
                parent.dataset.colorG = unselectedG;
                parent.dataset.colorB = unselectedB;
                paint = false;
                
            }
            // Otherwise we paint (as its unpainted or a different color)
            else {
                parent.dataset.modifier = "Paint";
                parent.dataset.colorR = colorR;
                parent.dataset.colorG = colorG;
                parent.dataset.colorB = colorB;
                parent.style.backgroundColor = "rgb(" + colorR + ", " + colorG + ", " + colorB + ")";
                paint = true;
            }
        }

        // Change the brightness in case we are painting a darkened box
        ChangeBoxBrightness(parent);
    }

    // Destroy the box that was clicked
    function Destroy() {
        // Get the box indeces
        var parent = this.parentElement;
        var [x, y, z] = parent.id.split(" ");
        x = Number(x);
        y = Number(y);
        z = Number(z);

        // Don't break the box if it was painted, if the parent is null (somehow), or we've already queued this box to be destroyed
        if (parent.dataset.modifier == 'Paint') {
            return;
        }
        if (parent.parentNode == null) {
            return;
        }
        if (destroyBox == parent.id) {
            return;
        }

        // Turn off the listener of the other faces to prevent duplicates
        var new_box = parent.cloneNode(true);
        parent.parentNode.replaceChild(new_box, parent);
        destroyBox = new_box;

        // Create a list of boxes that changed visibility, in case you break a required box and need to rehide them
        var changedVisibility = []

        // For the 3x3 grid centered on the box, make it visible
        for (i of [1, -1]) {
            // If the element exists unhide it and add it to the list if it was hidden
            var xElement = document.getElementById((x+i) + " " + y + " " + z);
            if (xElement != null) {
                if (xElement.style.visibility == "hidden" && xElement.dataset.region == "inner") {
                    changedVisibility.push(xElement)
                }
                xElement.dataset.region = "outer";
                ChangeBoxBrightness(xElement);
            }
            var yElement = document.getElementById(x + " " + (y+i) + " " + z);
            if (yElement != null) {
                if (yElement.style.visibility == "hidden" && yElement.dataset.region == "inner") {
                    changedVisibility.push(yElement)
                }
                yElement.dataset.region = "outer";
                ChangeBoxBrightness(yElement);
            }
            var zElement = document.getElementById(x + " " + y + " " + (z+i));
            if (zElement != null) {
                if (zElement.style.visibility == "hidden" && zElement.dataset.region == "inner") {
                    changedVisibility.push(zElement)
                }
                zElement.dataset.region = "outer";
                ChangeBoxBrightness(zElement);
            }
        }

        // Create a delay between the click and destruction for the held destruction
        setTimeout(function() {
            if (parent.dataset.required == "Required") {
                parent = new_box

                // Play animation of it breaking
                Explode(parent);
                parent.style.visibility = "hidden";

                // Wait for the animation to play out and stop user input and show the error
                // WAIT FOR THE ANIMATION TO PLAY OUT AND STOP USER INPUT AND SHOW THE ERROR

                // Rehide the blocks that were shown for the animation
                for (element of changedVisibility) {
                    element.style.visibility = "hidden";
                    element.dataset.region = "inner";
                }

                // Apply broken effect
                parent.style.visibility = "visible";
                parent.dataset.modifier = "Permanent";
                parent.dataset.region == "outer"
                parent.style.backgroundColor = "rgb(" + colorR + ", " + colorG + ", " + colorB + ")";
                parent.dataset.colorR = colorR;
                parent.dataset.colorG = colorG;
                parent.dataset.colorB = colorB;

                // Apply the broken texture to each of the faces
                parent.childNodes.forEach((face) => {
                    face.style.backgroundSize = face.style.backgroundSize + ', 100%'; 
                    face.style.backgroundImage = face.style.backgroundImage + ', url("./src/broken.svg")'; 
                });

                // Update the boxes array with the new box node
                boxes[x][y][z] = parent;
            } else {
                // Play animation of it breaking
                Explode(parent);

                // Remove the box from our array and the DOM
                const index = boxes[x][y].indexOf(parent);
                if (index > -1) {
                    boxes[x][y].splice(index, 1);
                }

                // If we are in edit mode, update the dimensions and slider
                if (isEditing) {
                    CheckMaxDimChange(x, y, z);
                    var [rotateX, rotateY, rotateZ] = container.style.transform.split(" ");
                    var xRad = Number(rotateX.substring(rotateX.indexOf("(")+1, rotateX.indexOf("rad")));
                    var yRad = Number(rotateY.substring(rotateY.indexOf("(")+1, rotateY.indexOf("rad")));
                    var zRad = Number(rotateZ.substring(rotateZ.indexOf("(")+1, rotateZ.indexOf("rad")));
                    SliderPositionUpdate(xRad, yRad, zRad);
                    document.getElementById("maxDim").innerHTML = xSize + " " + ySize + " " + zSize;
                }

                new_box.remove(); // WANT TO SEE IF I CAN MOVE IT UP, JUST SO ITS POSITONED TOWARDS THE OTHER DELETION ONES
            }
        }, 100);
    }

    // Create the explosion effect from a block
    function Explode(block) {
        // Get the values of the parent
        var [baseX, baseY, baseZ] = block.id.split(" ");
        baseX = Number(baseX);
        baseY = Number(baseY);
        baseZ = Number(baseZ);

        // Split it into a 2x2x2
        for (let i = 0; i < 1; i+=0.5) {
            for (let j = 0; j < 1; j+=0.5) {
                for (let k = -0.25; k <= 0.25; k+=0.5) {
                    // Calculate how the puzzle image should be offset
                    var leftPosition = 0;
                    var topPosition = 0;

                    if (i == 0.5) {
                        leftPosition = 50;
                    }
                    if (j == 0.5) {
                        topPosition = 50;
                    }

                    // Create and position the box
                    var box = CreateBox(baseX+i, baseY+j, baseZ+k, size/2, false, leftPosition, topPosition);

                    // Set the animation positions for the box
                    box.style.setProperty('--leftStart', box.style.left);
                    if (i == 0) {
                        box.style.setProperty('--leftEnd', `${size*(baseX-0.5 + i)}vmin`);
                    } else {
                        box.style.setProperty('--leftEnd', `${size*(baseX+0.5 + i)}vmin`);
                    }

                    box.style.setProperty('--topStart', box.style.top);
                    if (j == 0) {
                        box.style.setProperty('--topStart', `${size*(baseY + j - 0.25)}vmin`);
                        box.style.setProperty('--topEnd', `${size*(baseY+0.5 + j)}vmin`);
                    } else {
                        box.style.setProperty('--topEnd', `${size*(baseY+1.5 + j)}vmin`);
                    }

                    box.style.setProperty('--zStart', box.style.transform);
                    if (k == -0.25) {
                        box.style.setProperty('--zEnd', "translateZ(" + size*(baseZ-0.5 + k) + "vmin)");
                    } else {
                        box.style.setProperty('--zEnd', "translateZ(" + size*(baseZ+0.5 + k) + "vmin)");
                    }

                    // Rotate the box a random amount as its falling
                    box.style.setProperty('--rotateX', "rotateX(" + Math.floor(Math.random() * 360 - 180) + "deg");

                    box.classList.add("explode");
                    box.style.backgroundSize = "200%";

                    // Remove the box once we've finished the animation
                    box.addEventListener("animationend", function(){this.remove()});
                }
            }
        }
    }

    // Add a block to the level editor
    function AddBlock() {
        var parent = this.parentElement;

        var [parentX, parentY, parentZ] = this.parentElement.id.split(" ");
        parentX = Number(parentX);
        parentY = Number(parentY);
        parentZ = Number(parentZ);
        console.log(parentX, parentY, parentZ, this.id);

        // STILL NEEDS A LITTLE BIT OF CLEAN UP, I THINK ITS MAINLY ON BACK/LEFT/TOP SIDES

        // Prevent a dimension from going greater than 10
        if (this.id == "front" && parentZ != 9) {
            if (document.getElementById(parentX + " " + parentY + " " + (parentZ+1)) == null) {
                var box = CreateBox(parentX, parentY, parentZ+1)

                // Update hte max dim if needed
                if (parentZ+1 > zSize-1) {
                    zSize += 1;
                }

                // Add the required box arrays if needed to perserve boxes[x][y] order
                while (boxes.length < xSize) {
                    boxes.push([[]]);
                }
                while (boxes[parentX].length < ySize) {
                    boxes[parentX].push([]);
                }
                boxes[parentX][parentY].push(box) // z order doesnt matter
            }
        } else if (this.id == "right" && parentX != 9) {
            if (document.getElementById((parentX+1) + " " + parentY + " " + parentZ) == null) {
                var box = CreateBox(parentX+1, parentY, parentZ)
                if (parentX+1 > xSize-1) {
                    xSize += 1;
                }
                while (boxes.length < xSize) {
                    boxes.push([[]]);
                }
                while (boxes[parentX+1].length < ySize) {
                    boxes[parentX+1].push([]);
                }
                boxes[parentX+1][parentY].push(box);
            }
        } else if (this.id == "bottom" && parentY != 9) {
            if (document.getElementById(parentX + " " + (parentY+1) + " " + parentZ) == null) {
                var box = CreateBox(parentX, parentY+1, parentZ);
                if (parentY+1 > ySize-1) {
                    ySize += 1;
                }
                while (boxes.length < xSize) {
                    boxes.push([[]]);
                }
                while (boxes[parentX].length < ySize) {
                    boxes[parentX].push([]);
                }
                boxes[parentX][parentY+1].push(box);
            }
        }
        // PROBABLY DO SOME \.SIZE/ MANIPULATION
        // IDEALLY SHIFT EVERYTHING DOWN WHEN NEEDED SO YOUR NOT FORCED WITH A TRUE TOP LEFT
        else if (this.id == "back" && parentZ != 0) {
            if (document.getElementById(parentX + " " + parentY + " " + (parentZ-1)) == null) {
                var box = CreateBox(parentX, parentY, parentZ-1)
                boxes[parentX][parentY].push(box);
            }
        } else if (this.id == "left" && parentX != 0) {
            if (document.getElementById((parentX-1) + " " + parentY + " " + parentZ) == null) {
                var box = CreateBox(parentX-1, parentY, parentZ)
                boxes[parentX-1][parentY].push(box);
            }
        } else if (this.id == "top" && parentY != 0) {
            if (document.getElementById(parentX + " " + (parentY-1) + " " + parentZ) == null) {
                var box = CreateBox(parentX, parentY-1, parentZ)
                boxes[parentX][parentY-1].push(box);
            }
        }

        // Update the slider position
        var [rotateX, rotateY, rotateZ] = container.style.transform.split(" ");
        var xRad = Number(rotateX.substring(rotateX.indexOf("(")+1, rotateX.indexOf("rad")));
        var yRad = Number(rotateY.substring(rotateY.indexOf("(")+1, rotateY.indexOf("rad")));
        var zRad = Number(rotateZ.substring(rotateZ.indexOf("(")+1, rotateZ.indexOf("rad")));
        SliderPositionUpdate(xRad, yRad, zRad);

        // ALSO UNSURE WHAT THIS IS DOING OR IF ITS NEEDED
        var hideX = 0;
        var hideZ = 0;

        document.getElementById("maxDim").innerHTML = xSize + " " + ySize + " " + zSize;
    }

    // Check if the max dimension changed, editor only
    // UNSURE IF THIS IS WORKING 100% CORRECTLY
    function CheckMaxDimChange(x, y, z) {
        // Check Y dim
        var removeAll = true;
        for (let i = 0; i < boxes.length; i++) {
            if (boxes[i].length >= ySize) {
                if (boxes[i][ySize-1].length > 0) {
                    removeAll = false;
                    break;
                }
            }
        }
        if (removeAll) {
            boxes[x].splice(y, 1);
            ySize--;
            CheckMaxDimChange(x, y-1, z);
        }

        // Check X dim
        var removeAll = true;
        if (boxes[x] != undefined) {
            for (let i = 0; i < boxes[x].length; i++) {
                if (boxes[x][i].length > 0) {
                    removeAll = false;
                    break;
                }
            }
            if (removeAll) {
                if (x >= xSize-1) {
                    boxes.splice(x, 1);
                    xSize--;
                    CheckMaxDimChange(x-1, y, z)
                }
                console.log(x, xSize);
            }
        }

        // Check Z dim
        var removeAll = true;
        for (let i = 0; i < boxes.length; i++) {
            for (let j = 0; j < boxes[i].length; j++) {
                for (let k = 0; k < boxes[i][j].length; k++) {
                    if (boxes[i][j][k].id.split(" ")[2] >= zSize-1) {
                        removeAll = false;
                        break;
                    }
                }
            }
        }
        if (removeAll) {
            zSize--;
            CheckMaxDimChange(x, y, z-1)
        }
    }

</script>
</body>
</html>
